## 练习3.1

> 使用恰当的using 声明重做 1.4.1节和2.6.2节的练习。

### [3.1.1](ex01_1.cpp)


### [3.1.2](ex01_2.cpp)


### [3.1.3](ex01_3.cpp)


### [3.1.4](ex01_4.cpp)

  
## 练习3.2

> 编写一段程序从标准输入中一次读入一行，然后修改该程序使其一次读入一个词。

### [3.2.1](ex02_1_stringcin.cpp)

### [3.2.2](ex02_2_stringcin.cpp)

  
## 练习3.3 

> 请说明string类的输入运算符和getline函数分别是如何处理空白字符的。

输入运算符碰到空格、回车和制表符，忽略前面空白；getline碰到回车，不忽略空白。  
  
## 练习3.4

> 编写一段程序读取两个字符串，比较其是否相等并输出结果。如果不相等，输出比较大的那个字符串。改写上述程序，比较输入的两个字符串是否等长，如果不等长，输出长度较大的那个字符串。

### [3.4.1](ex04_1_strcompare.cpp)


### [3.4.2](ex04_2_strcompare.cpp)

  
## 练习3.5

> 编写一段程序从标准输入中读入多个字符串并将他们连接起来，输出连接成的大字符串。然后修改上述程序，用空格把输入的多个字符串分割开来。

### [3.5.1](ex05_1_strsum.cpp)

### [3.5.2](ex05_2_strsum.cpp)

  
## [练习3.6](ex06_str_for.cpp)

> 编写一段程序，使用范围for语句将字符串内所有字符用X代替。


  
## [练习3.7](ex07.cpp)

> 就上一题完成的程序而言，如果将循环控制变量的类型设置为char将发生什么？先估计一下结果，然后实际编程进行验证。

将变量的类型设置为char，即将变量的基本类型设置为char，与auto自动推断的类型相同，因此，结果与上题结果相同。  

  
## 练习3.8

> 分别用while循环和传统for循环重写第一题的程序，你觉得哪种形式更好呢？为什么？

个人感觉范围for循环更好，更简洁，且声明的变量作用域在范围for循环内，不会对其他程序产生影响。  
### [3.8.1](ex08_1.cpp)


### [3.8.2](ex08_2.cpp)

  
## 练习3.9

> 下面的程序有何作用？它合法吗？如果不合法？为什么？
```cpp
string s;
cout << s[0] << endl;
```

合法，定义后就占用一个字节，包含'\0'。  
  
## [练习3.10](ex10_str.cpp)

> 编写一段程序，读入一个包含标点符号的字符串，将标点符号去除后输出字符串剩余的部分。


  
## 练习3.11

> 下面的范围for语句合法吗？如果合法，c的类型是什么？
```cpp
const string s = "Keep out!";
for(auto &c : s){ /* ... */ }
```

合法，对const char的引用，但是不能改变c。  
  
## 3.12
## 练习3.12

> 下列vector对象的定义有不正确的吗？如果有，请指出来。对于正确的，描述其执行结果；对于不正确的，说明其错误的原因。
```cpp
vector<vector<int>> ivec;
vector<string> svec = ivec;
vector<string> svec(10, "null");
```

（a）正确，创建了元素为vector的vector对象；  
（b）错误，vector元素类型不一致；  
（c）正确，创建了一个包含10个元素为“null”的vector对象。  
  
## 练习3.13

> 下列的vector对象各包含多少个元素？这些元素的值分别是多少？
```cpp
vector<int> v1;
vector<int> v2(10);
vector<int> v3(10, 42);
vector<int> v4{ 10 };
vector<int> v5{ 10, 42 };
vector<string> v6{ 10 };
vector<string> v7{ 10, "hi" };
```

（a）包含0个元素；（b）包含10个元素，值都为0；  
（c）包含10个元素，值都为42；（d）包含1个元素，值为10；  
（e）包含2个元素，值为10，42；（f）包含10个元素，空字符串；（g）包含10个元素，值都为“hi”。  
  
## [练习3.14](ex14_ivector.cpp)

> 编写一段程序，用cin读入一组整数并把它们存入一个vector对象。


  
## [练习3.15](ex15_svector.cpp)

> 改写上题程序，不过这次读入的是字符串。


  
## [练习3.16](ex16_sizevector.cpp)

> 编写一段程序，把练习3.13中vector对象的容量和具体内容输出出来


  
## [练习3.17](ex17.cpp)

> 从cin读入一组词并把它们存入一个vector对象，然后设法把所有词都改为大写形式。输出改变后的结果，每个词占一行。


  
## 练习3.18

> 下面的程序合法吗？如果不合法，你准备如何修改？
```cpp
vector<int> ivec;
ivec[0] = 42;
```

不合法，第2行改为：ivec.push_back(10)。  
  
## 练习3.19

> 如果想定义一个含有10个元素的vector对象，所有元素的值都是42，请例举三种不同的实现方法，哪种方式更好呢？

```cpp
vector<int> ivec1(10,42);	//最好，大量重复值，简洁
vector<int> ivec2{ 42, 42, 42, 42, 42, 42, 42, 42, 42, 42};
vector<int> ivec3 = { 42, 42, 42, 42, 42, 42, 42, 42, 42, 42};
vector<int> ivec4(ivec1);
vector<int> ivec4 = ivec1;
```
  
## [练习3.20](ex20.cpp)

> 读入一组整数并把他们存入一个vector对象，将每对相邻整数的和输出出来。改写你的程序，这次要求先输出第一个和最后一个元素的和，接着输入第二个和倒数第二个元素的和，以此类推。


  
## [练习3.21](ex21.cpp)

> 请使用迭代器重做3.3.3节的第一个练习。


  
## [练习3.22](ex22.cpp)

> 修改之前那个输出text第一段的程序，首先把text的第一段全部改成大写形式，然后输出它。


  
## [练习3.23](ex23.cpp)

> 编写一段程序，创建一个含有10个整数的vector对象，然后使用迭代器将所有元素的值都变成原来的两倍。输出vector对象的内容，检验程序是否正确。


  
## [练习3.24](ex24.cpp)

> 请使用迭代器重做3.3.3节的最后一个练习。


  
## [练习3.25](ex25.cpp)

> 3.3.3节划分分数段的程序是使用下标运算符实现的，请利用迭代器改写该程序实现完全相同的功能。


  
## 练习3.26

> 在100页的二分搜索程序中，为什么用的是 mid = beg + (end - beg) / 2, 而非 mid = (beg + end) / 2 ; ?

迭代器相加不成立，指针加指针无意义。

## 练习3.27

> 假设txt_size 是一个无参函数，它的返回值是int。请回答下列哪个定义是非法的，为什么？
```cpp
unsigned buf_size = 1024;
(a) int ia[buf_size];
(b) int ia[4 * 7 - 14];
(c) int ia[txt_size()];
(d) char st[11] = "fundamental";
```

（a）非法；（b）合法；  
（c）非法；（d）非法。  
  
## 练习3.28

> 下列数组中元素的值是什么？
```cpp
string sa[10];
int ia[10];
int main() {
    string sa2[10];
    int ia2[10];
}
```

sa：空字符串；  
ia：0；  
sa2：空字符串；  
ia2：不确定值。  
  
## 练习3.29

> 相比于vector 来说，数组有哪些缺点，请例举一些。

数组的缺点：数组的大小是确定不变的，不能随意向数组中增加元素，丧失了vectoer的灵活性，没有API，风险更大。  
  
## 练习3.30

> 指出下面代码中的索引错误。
```cpp
constexpr size_t array_size = 10;
int ia[array_size];
for (size_t ix = 1; ix <= array_size; ++ix)
    ia[ix] = ix;
```

数组越界ix < array_size。  
  
## [练习3.31](ex31.cpp)

> 编写一段程序，定义一个含有10个int的数组，令每个元素的值就是其下标值。


  
## [练习3.32](ex32.cpp)

> 将上一题刚刚创建的数组拷贝给另一数组。利用vector重写程序，实现类似的功能。


  
## 练习3.33

> 对于104页的程序来说，如果不初始化scores将会发生什么？

数组的值为不确定的。  
  
## 练习3.34

> 假定p1 和 p2 都指向同一个数组中的元素，则下面程序的功能是什么？什么情况下该程序是非法的？
```cpp
p1 += p2 - p1;
```

将p1移动（p2-p1）个位置；p1或p2是非法的，该程序就是非法的。  
  
## [练习3.35](ex35.cpp)

> 编写一段程序，利用指针将数组中的元素置为0。


  
## [练习3.36](ex36.cpp)

> 编写一段程序，比较两个数组是否相等。再写一段程序，比较两个vector对象是否相等。


  
## 练习3.37

> 下面的程序是何含义，程序的输出结果是什么？
```cpp
const char ca[] = { 'h', 'e', 'l', 'l', 'o' };
const char *cp = ca;
while (*cp) {
    cout << *cp << endl;
    ++cp;
}
```

没有'\0'，循环可能不会停止，将会打印出垃圾信息（存在风险）。  
  
## 练习3.38

> 在本节中我们提到，将两个指针相加不但是非法的，而且也没有什么意义。请问为什么两个指针相加没有意义？

指针相加实际为地址相加，没有什么意义。  
  
## [练习3.39](ex39.cpp)

> 编写一段程序，比较两个string对象。再编写一段程序，比较两个C风格字符串的内容。


  
## [练习3.40](ex40.cpp)

> 编写一段程序，定义两个字符数组并用字符串字面值初始化它们；接着再定义一个字符数组存放前面两个数组连接后的结果。使用strcpy和strcat把前两个数组的内容拷贝到第三个数组当中。


  
## [练习3.41](ex41.cpp)

> 编写一段程序，用整型数组初始化一个vector对象。


  
## [练习3.42](ex42.cpp)

> 编写一段程序，将含有整数元素的vector对象拷贝给一个整型数组。


  
## [练习3.43](ex43.cpp)

> 编写3个不同版本的程序，令其均能输出ia的元素。版本1使用范围for语句管理迭代过程；版本2和版本3都使用普通for语句，其中版本2要求使用下标运算符，版本3要求使用指针。此外，在所有3个版本的程序中都要直接写出数据类型，而不能使用类型别名、auto关键字和decltype关键字。


  
## [练习3.44](ex44.cpp)

> 改写上一个练习中的程序，使用类型别名来代替循环控制变量的类型。


  
## [练习3.45](ex45.cpp)

> 再一次改写程序，这次使用auto关键字。

