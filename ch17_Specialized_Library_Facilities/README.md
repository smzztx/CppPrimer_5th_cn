## [练习17.1](ex01.cpp)

> 定义一个保存三个 int 值的 tuple，并将其成员分别初始化为10、20和30。


  
## 练习17.2

> 定义一个 tuple，保存一个 string、一个vector<string> 和一个 pair<string, int>。

参见17.1。
  
## [练习17.3](ex03)

> 重写12.3节中的 TextQuery 程序，使用 tuple 代替 QueryResult 类。你认为哪种设计更好？为什么？

第一种设计更好，第二种设计更容易实现，但不容易重构。  

  
## [练习17.4](ex04)

> 编写并测试你自己版本的 findBook 函数。


  
## [练习17.5](ex05)

> 重写 findBook，令其返回一个 pair，包含一个索引和一个迭代器pair。


  
## [练习17.6](ex06)

> 重写 findBook，不使用tuple和pair。


  
## 练习17.7

> 解释你更倾向于哪个版本的findBook，为什么。

tuple版本的findBook，更简洁。  
  
## 练习17.8

> 在本节最后一段代码中，如果我们将Sales_data()作为第三个参数传递给accumulate，会发生什么？

返回的Sales_data中的bookNo成员为空。  
  
## 练习17.9

> 解释下列每个bitset 对象所包含的位模式：
```cpp
(a) bitset<64> bitvec(32);
(b) bitset<32> bv(1010101);
(c) string bstr; cin >> bstr; bitset<8> bv(bstr);
```

（a）用unsigned值初始化：0000000000000000000000000000000000000000000000000000000000100000；  
（b）用unsigned值初始化：00000000000011110110100110110101；  
（c）用string初始化：取决于cin。  
  
## [练习17.10](ex10.cpp)

> 使用序列1、2、3、5、8、13、21初始化一个bitset，将这些位置置位。对另一个bitset进行默认初始化，并编写一小段程序将其恰当的位置位。


  
## [练习17.11](ex11.cpp)

> 定义一个数据结构，包含一个整型对象，记录一个包含10个问题的真/假测验的解答。如果测验包含100道题，你需要对数据结构做出什么改变（如果需要的话）？


  
## [练习17.12](ex12.cpp)

> 使用前一题中的数据结构，编写一个函数，它接受一个问题编号和一个表示真/假解答的值，函数根据这两个参数更新测验的解答。



  
## [练习17.13](ex13.cpp)

> 编写一个整型对象，包含真/假测验的正确答案。使用它来为前两题中的数据结构生成测验成绩。


  
## [练习17.14](ex14.cpp)

> 编写几个正则表达式，分别触发不同错误。运行你的程序，观察编译器对每个错误的输出。


  
## [练习17.15](ex15.cpp)

> 编写程序，使用模式查找违反“i在e之前，除非在c之后”规则的单词。你的程序应该提示用户输入一个单词，然后指出此单词是否符号要求。用一些违反和未违反规则的单词测试你的程序。

gcc version 4.8.4 对regex支持有问题，请使用4.9及以上版本。  

```sh
$ ./ex15 
believe
believe: correct
freind
freind: error
receipt
receipt: correct
theif
theif: error
receive
receive: correct
```
  
## [练习17.16](ex16.cpp)

> 如果前一题程序中的regex对象用"[^c]ei"进行初始化，将会发生什么？用此模式测试你的程序，检查你的答案是否正确。
这样只匹配3个字符，（非c）和ei这3个字符，匹配成功后result中只有3个字符。  
这里就按照题意写规则。  

```sh
$ ./ex16 
freind
freind: correct
1: rei 
```

## [练习17.17](ex17.cpp)

> 更新你的程序，令它查找输入序列中所有违反"ei"语法规则的单词。


```sh
$ ./ex17 
freind
theif
```
  
## [练习17.18](ex18.cpp)

> 修改你的程序，忽略包含“ei”但并非拼写错误的单词，如“albeit”和“neighbor”。


  
## 练习17.19

> 为什么可以不先检查m[4]是否匹配了就直接调用m[4].str()？

没有匹配则返回为空字符串，也是可以比较的。  
  
## [练习17.20](ex20.cpp)

> 编写你自己版本的验证电话号码的程序。


  
## [练习17.21](ex21.cpp)

> 使用本节定义的valid 函数重写8.3.2节中的电话号码程序。


  
## [练习17.22](ex22.cpp)

> 重写你的电话号码程序，使之允许在号码的三个部分之间放置任意多个空白符。


```sh
$ ./ex22 
908.555.1500
valid: 908.555.1500
908   555   1500
valid: 908   555   1500
```
  
## [练习17.23](ex23.cpp)

> 编写查找邮政编码的正则表达式。一个美国邮政编码可以由五位或九位数字组成。前五位数字和后四位数字之间可以用一个短横线分隔。


```sh
$ ./ex23
111112222
valid: 111112222
11111-2222
valid: 11111-2222
11111
valid: 11111
11111-
not valid: 11111-
```
  
## [练习17.24](ex24.cpp)

> 编写你自己版本的重拍电话号码格式的程序。


  
## [练习17.25](ex25.cpp)

> 重写你的电话号码程序，使之只输出每个人的第一个电话号码。


  
## [练习17.26](ex26.cpp)

> 重写你的电话号码程序，使之对多于一个电话号码的人只输出第二个和后续号码。


  
## [练习17.27](ex27.cpp)

> 编写程序，将九位数字邮政编码的格式转换为 ddddd-dddd。


  
## [练习17.28](ex28.cpp)

> 编写函数，每次调用生成并返回一个均匀分布的随机unsigned int。


  
## [练习17.29](ex29.cpp)

> 修改上一题中编写的函数，允许用户提供一个种子作为可选参数。


  
## [练习17.30](ex30.cpp)

> 再次修改你的程序，此次增加两个参数，表示函数允许返回的最小值和最大值。


  
## 练习17.31

> 对于本节中的游戏程序，如果在do循环内定义b和e，会发生什么？

每次的随机数都相同。
  
## 练习17.32

> 如果我们在循环内定义resp，会发生什么？

会报错，未定义resp。
  
## [练习17.33](ex33.cpp)

> 修改11.3.6节中的单词转换程序，允许对一个给定单词有多种转换方式，每次随机选择一种进行实际转换。


  
## 练习17.34

> 编写一个程序，展示如何使用表17.17和表17.18中的每个操作符。

略。  
  
## [练习17.35](ex35.cpp)

> 修改第670页中的程序，打印2的平方根，但这次打印十六进制数字的大写形式。

这里要使用gcc5及之后的版本编译。  
[Missing ios_base::hexfloat format specifier](https://gcc.gnu.org/bugzilla/show_bug.cgi?id=59987)  

  
## [练习17.36](ex36.cpp)

> 修改上一题中的程序，打印不同的浮点数，使它们排成一列。


  
## [练习17.37](ex37.cpp)

> 用未格式化版本的getline 逐行读取一个文件。测试你的程序，给定一个文件，既包含空行又包含长度超过你传递给geiline的字符数组大小的行。

[basic_istream::getline, if it extracts no characters, if it fills in the provided buffer without encountering the delimiter, or if the provided buffer size is less than 1.](https://en.cppreference.com/w/cpp/io/ios_base/iostate)

  
## [练习17.38](ex38.cpp)

> 扩展上一题中你的程序，将读入的每个单词打印到它所在的行。



  
## [练习17.39](ex39.cpp)

> 对本节给出的 seek程序，编写你自己的版本。

